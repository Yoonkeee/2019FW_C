#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define print printf

void findOperator(char*);
int findDot(char*);
char* fillZeroInt(char*, char*);
char* fillZeroDec(char*, char*);
char* calPlus(char*, char*);
char* calMinus(char*, char*);
int abs_compare(char*, char*);
char* minus_exception(char*, char*);
char *result, *X, *Y;
char* find_first_negative(char*);
char* calMultiply(char*, char*);
char* remove_dot(char*);
int first_negative = 0;  // 첫 숫자가 음수일 경우 1, default 0
//int A_bigger_abs = 0;  // 첫 숫자 A가 음수이며 덧셈할 B보다 값이 더 클 경우 1, default 0
const int MSIZE = 50;  // malloc시 임시로 사용할 사이즈. 코드 완성 후엔 각 선언마다 적절한 lenth로 계산해서 사용할 것
// end definition

int main() {
//    char input[] = "";
    X = (char*)malloc(sizeof(char) * MSIZE);
    Y = (char*)malloc(sizeof(char) * MSIZE);
    result = (char*)malloc(sizeof(char) * MSIZE);
//    scanf("%s", X);
//    scanf("%s", Y);
    X = "-123";
    Y = "500";
    X = find_first_negative(X);
    X = fillZeroInt(Y, X);
    Y = fillZeroInt(X, Y);
    X = fillZeroDec(Y, X);
    Y = fillZeroDec(X, Y);
    
    result = calPlus(X, Y);  // result에 덧셈 결과 저장
//    result = calMinus(X, Y);  // result에 뺄셈 결과 저장
//    findOperator(input);
    printf("X : %s \nY : %s \n", X, Y);  // 현재 A, B값 (자리수까지 맞추어져있음)
    printf("result : %s\n", result);
    return 0;
}  // end main()

char* calMultiply(char *X, char *Y) {  // 곱셈
    char *A, *B;
    A = remove_dot(X);
    B = remove_dot(Y);
    
    return 0;
}  // end calMultiply()

char* remove_dot(char *S) {
    char *temp = (char*)malloc(sizeof(char) * sizeof(S));
    char *A = S;
    int i, index_of_dot;
    index_of_dot = findDot(A);
    char *temp_return;
    for(i=0; i<=index_of_dot; i++, A++)
        temp[i] = *A;
    return temp_return;
}

char* calPlus(char *X, char*Y) {  // 덧셈
    if(first_negative) return minus_exception(X, Y);
    int i, sum, oneA, oneB, carry=0;
    char *A = X, *B = Y;  // X,Y로 받아 A,B로 이름 바꿔서 사용
    char *returningResult, doPlus, *temp;
    int lengthA = strlen(A);
    temp = (char*)malloc(sizeof(char));
    returningResult = (char*)malloc(sizeof(char) * strlen(X));
    for(i = 0; i < lengthA-1; i++, A++, B++) continue;  // A와 B의 포인터 위치를 맨 끝으로 이동하여 맨 뒤부터 계산하도록 함
    for(i = lengthA-1 ; i >= 0 ; i--, A--, B--) {  // 맨 뒤부터 앞으로 한칸씩 수행
        if(*A == '.' || *B == '.') {  // 소수점을 만나게 되면 점을 찍고 다음 반복 수행
            returningResult[i] = '.';
            continue;
        }
        oneA = *A - 48;  // ASCII 값 중 0~9로 위치하도록 보정
        oneB = *B - 48;
        sum = oneA + oneB;  // 덧셈 수행
        if(carry) {  // 지난 덧셈에서 carry가 있을 경우 sum에 carry를 더함
            sum += carry;
            carry = 0;  // carry 사용 후 0으로 초기화
        }
        doPlus = (sum % 10) + 48;  // ASCII 0~9값 설정
        if(sum >= 10) carry++;  // 만약 합이 10보다 클 경우 carry++
        returningResult[i] = doPlus;  // 현재 위치에 덧셈 결과 넣음
    }
    if(carry) {  // 맨 앞까지 덧셈을 끝낸 후 carry가 있다면 결과값 맨 앞에 1을 추가
        strcat(temp, "1");
        strcat(temp, returningResult);
        returningResult = temp;
    }
    return returningResult;
}  // end calPlus

char* find_first_negative(char* X) {
    if(*X == '-') {
        X++;
        first_negative = 1;
    }
    return X;
}  // end find_first_negative()

int abs_compare(char* X, char* Y) {
    int lengthA = findDot(X);
    int lengthB = findDot(Y);
    char *A = X, *B = Y;
    if(lengthA > lengthB)
        return 1;
    else if(lengthA == lengthB) {
        if(*A > *B)
            return 1;
        else {
            A++;
            B++;
        }
    }
    return 0;
}  // end abs_compare()

char* minus_exception(char *X, char *Y) {
    // -5 + 11  -> (11-5) =  6 -> -A + B = +(B - A)
    // -5 +  2  -> -(5-2) = -3 -> -A + B = -(A - B)  -> ** 예외 처리 할 case **
    // 음수 + 양수 의 경우 음수, 양수간의 절대값 대수 비교가 필요.
    // 계산은 절대값간의 뺄셈으로 이루어지나, 음수가 더 클 경우 최종 결과 음수 / 양수가 더 클 경우 최종 결과 양수.
    char *A=X, *B=Y;
    char *temp_return, *temp;
    int A_bigger_abs = 0;
    A_bigger_abs = abs_compare(X, Y);  // X의 절대값이 Y보다 클 경우 A_bigger_abs = 1
    first_negative = 0;
    temp_return = (char*)malloc(sizeof(char) * MSIZE);
    if(A_bigger_abs) {  // A<0 && abs(A) > abs(B)
        temp = (char*)malloc(sizeof(char) * MSIZE);
        temp_return = calMinus(A, B);
        strcat(temp, "-");  // 마이너스 부호 붙임
        strcat(temp, temp_return);
        temp_return = temp;
    } else  // A<0 && abs(B) > abs(A)
        temp_return = calMinus(B, A);
    // end if
    A_bigger_abs = 0;
    return temp_return;
}  // end minus_exception

char* calMinus(char *X, char*Y) {  // 뺄셈
    int i, sum, oneA, oneB, carry=0;
    char *A, *B;  // A와 B를 바꿀 부분  <<----- B > A 라서 뺄셈시 음수가 될 때
    A = X; B = Y;  // X,Y로 받아 A,B로 이름 바꿔서 사용
    char *returningResult, doMinus, *temp;
    int lengthA = strlen(A);
    temp = (char*)malloc(sizeof(char));
    returningResult = (char*)malloc(sizeof(char) * strlen(X));
    for(i = 0; i < lengthA-1; i++, A++, B++) continue;  // A와 B의 포인터 위치를 맨 끝으로 이동하여 맨 뒤부터 계산하도록 함
    for(i = lengthA-1 ; i >= 0 ; i--, A--, B--) {
        if(*A == '.' || *B == '.') {  // 소수점을 만나게 되면 점을 찍고 다음 반복 수행
            returningResult[i] = '.';
            continue;
        }
        oneA = *A - 48;  // ASCII 값 중 0~9로 위치하도록 보정
        oneB = *B - 48;
        sum = oneA - oneB;  // 뺄셈 수행
        if(carry) {  // 직전 반복 뺼셈에서 carry 발생했을 경우 -1
            sum--;
            carry = 0;  // carry 사용 후 0으로 초기화
        }
        if(sum < 0 && i == 0) {  // 맨 앞자리 뺄셈인데 음수일 경우
            sum *= -1;  // 양수화
            carry++;  // 캐리 ++
        } else if(sum < 0) {  // 뺄셈이 음수일 경우
            sum += 10;  // 10을 더하고 캐리 ++
            carry++;
        }
        doMinus = (sum % 10) + 48;  // ASCII 0~9값 설정
        returningResult[i] = doMinus;
    }
    if(carry) {  // 계산을 끝까지 마치고도 캐리가 있는 경우 = 계산 결과가 음수가 된 경우
        strcat(temp, "-");  // 마이너스 부호 붙임
        strcat(temp, returningResult);
        returningResult = temp;
    }
    return returningResult;
}  // end calMinus

char* fillZeroInt(char* A, char* B) {  // 덧셈, 뺄셈시 정수부 자리수가 차이나는 만큼 0으로 채움
    int integerOfA = findDot(A);  // A의 정수부 길이
    int integerOfB = findDot(B);  // B의 정수부 길이
    int differenceInt = integerOfA - integerOfB;
    char *tempA = A;  // A를 tempA에 복사
    char *tempB = B;  // B를 tempB에 복사
    char *temp = (char*)malloc((strlen(A) + differenceInt) * sizeof(char));  // 두 수의 자릿수가 차이나는 만큼 0으로 채울 공간

    differenceInt = integerOfA - integerOfB;
    if(integerOfA > integerOfB) {  // 정수부가 A가 B보다 긴 경우
        for( ; differenceInt > 0; differenceInt--)  // 차이나는 만큼 0으로 채움
            strcat(temp, "0");
//        strcat(tempInt, tempB);
//        return tempInt;
    }
    strcat(temp, tempB);
    return temp;
}  // end plus

char* fillZeroDec(char *A, char *B) {  // 덧셈, 뺄셈시 소수부 자리수가 차이나는 만큼 0으로 채움
    int integerOfA = findDot(A);  // A의 정수부 길이
    int integerOfB = findDot(B);  // B의 정수부 길이
    int decimalOfA = strlen(A) - integerOfA;  // A의 소수부 길이
    int decimalOfB = strlen(B) - integerOfB;  // B의 소수부 길이
    int differenceDec = decimalOfA - decimalOfB;
    if(differenceDec <= 0) return B;
    char *tempA = A;  // A를 tempA에 복사
    char *tempB = B;  // B를 tempB에 복사
    char *temp = (char*)malloc((strlen(A) + differenceDec) * sizeof(char));  // 두 수의 자릿수가 차이나는 만큼 0으로 채울 공간
    char *temp2 = (char*)malloc((strlen(A) + differenceDec) * sizeof(char));  // 두 수의 자릿수가 차이나는 만큼 0으로 채울 공간

    if(differenceDec > 0)   // A의 소수부가 더 긴 경우
        for( ; differenceDec > 0; differenceDec--)
            strcat(temp, "0");
    strcat(temp2, tempB);
    strcat(temp2, temp);
    return temp2;
}

int findDot(char* num) {  // 소수점까지의 length(정수부 길이)를 찾아 return함
    int lenOfNumber = strcspn(num, ".");
    return lenOfNumber;
}

void findOperator(char* input) {
    int i;
    int size = strlen(input);
    print("%d",size);
    for(i = 0; i < size; i++) {
        if(isdigit(input[i]) == 0) {  // 정수가 아닌 문자 탐지
            switch(input[i]) {
                case '+':  // 덧셈 +
                    break;
                case '-':  // 뺄셈 -
                    break;
                case '*':  // 곱셈 *
                    break;
                default:  // 잘못 입력된 경우
                    print("\n!! Unavailable input !!\n");
                    exit(0);
            }  // end switch
        }  // end if
    }  // end for
}  // end findOperator
